Phase 1: Project Setup and Smart Contracts (Solidity)
This phase focuses on establishing the foundation of your blockchain interaction.

1. Project Setup (Hardhat)

What we'll do: Initialize a Hardhat project, which is a development environment for Ethereum smart contracts.

Tools: Node.js, npm/yarn, Hardhat.

# Ensure you have Node.js and npm installed
# Install Hardhat globally (optional but recommended for easier use)
npm install -g hardhat

# Create a new directory for your project
mkdir qain-project
cd qain-project

# Initialize a Hardhat project
hardhat init

# Follow the prompts. Choose "Create a basic sample project" and then "Solidity".
# This will create necessary folders like 'contracts', 'scripts', 'test'.
Install necessary packages:

cd qain-project
npm install --save-dev @openzeppelin/contracts @nomiclabs/hardhat-ethers ethers
# For Chainlink integration later, you'll need these:
npm install --save-dev @chainlink/contracts
Configure hardhat.config.js: This file tells Hardhat about your compiler version, networks (for deployment), etc.

/**
 * @type import('hardhat/config').HardhatUserConfig
 */
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-etherscan"); // For Etherscan verification

// Load environment variables from a .env file (optional, but good for private keys)
// require('dotenv').config();

// Example network configuration (you'll add your own later for deployment)
const ALCHEMY_API_KEY = process.env.ALCHEMY_API_KEY;
const PRIVATE_KEY = process.env.PRIVATE_KEY; // Your wallet private key

module.exports = {
  solidity: {
    version: "0.8.19", // Use a compatible Solidity version
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    // Example for Sepolia testnet (you'll need to set up a .env file)
    // sepolia: {
    //   url: `https://eth-sepolia.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    //   accounts: [`0x${PRIVATE_KEY}`]
    // }
    // Add other networks like Goerli, mainnet, Polygon, etc. as needed.
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};
2. Developing Smart Contracts (contracts/)

QAINToken.sol (ERC-20 Token)

We'll use OpenZeppelin's robust ERC-20 implementation.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract QAINToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20("QAIN Token", "QAIN") {
        _mint(msg.sender, initialSupply * (10 ** decimals()));
    }

    // Function to mint more tokens (only by owner)
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    // You can add more features here, like staking, burning, etc.
}
Rewarder.sol (Incentive Mechanism)

This contract will hold a portion of QAIN tokens and distribute them based on certain conditions. Let's start simple: distribute tokens to users who submit valid AI proofs.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./ProofOfAI.sol"; // We'll define this next
import "@openzeppelin/contracts/access/Ownable.sol";

contract Rewarder is Ownable {
    IERC20 public qainToken;
    ProofOfAI public proofOfAIContract; // Contract that stores AI proofs

    // Mapping to track rewards distributed to prevent re-claiming
    mapping(address => bool) public hasClaimedReward;

    event RewardDistributed(address indexed user, uint256 amount);
    event TokensDeposited(address indexed depositor, uint256 amount);

    constructor(address _qainTokenAddress, address _proofOfAIAddress) {
        qainToken = IERC20(_qainTokenAddress);
        proofOfAIContract = ProofOfAI(_proofOfAIAddress);
    }

    // Function to deposit QAIN tokens into the rewarder contract
    function depositTokens(uint256 amount) public {
        require(amount > 0, "Amount must be greater than zero");
        qainToken.transferFrom(msg.sender, address(this), amount);
        emit TokensDeposited(msg.sender, amount);
    }

    // Function to claim a reward for a validated AI proof
    function claimReward() public {
        require(!hasClaimedReward[msg.sender], "Reward already claimed");
        // Basic condition: check if the user has at least one successful AI proof
        // You'll need to define how ProofOfAIContract stores and verifies this.
        // For now, let's assume ProofOfAIContract has a function like `getSuccessfulProofsCount(address user)`
        // or a mapping `userHasValidProof[msg.sender]`.

        // For simplicity, let's assume ProofOfAI contract will emit an event when a proof is valid,
        // and Rewarder listens to it (or checks a state).
        // Let's refine this interaction later. For now, a placeholder logic:
        // require(proofOfAIContract.hasSufficientValidProofs(msg.sender), "No valid proofs to reward");

        // Let's simplify for now: Rewarder distributes tokens to anyone who *calls* claimReward,
        // assuming an external mechanism validates the proof first and allows the caller.
        // A more robust mechanism would be the ProofOfAI contract notifying the Rewarder.

        // Placeholder logic: If user has ever submitted a proof, they can claim.
        // This needs to be tied to successful verification from ProofOfAI.
        // We will improve this.

        // For now, let's just simulate rewarding the caller if they call this.
        // A real implementation would require ProofOfAIContract to mark them eligible.

        // --- REFINEMENT ---
        // Let's assume ProofOfAIContract has a state `isValidProofSubmitted[msg.sender]` set to true by its logic.
        // We need to query that.

        // We need ProofOfAI.sol first to define how it stores validity.
        // For now, let's put a placeholder and come back to it.

        // --- TEMPORARY PLACEHOLDER ---
        // Assume the user is rewarded if they have submitted *any* proof, and they haven't claimed yet.
        // This will be heavily modified once ProofOfAI is designed.

        // Let's assume ProofOfAI has a public getter for proof validity of a specific user.
        // For example: `function getUserProofStatus(address user) public view returns (bool)`

        // Mocking the eligibility check:
        // For now, if the caller has initiated a proof submission, and they haven't claimed:
        // require(proofOfAIContract.checkIfEligibleForReward(msg.sender), "Not eligible for reward");
        // This `checkIfEligibleForReward` needs to be implemented in ProofOfAI.

        // --- Let's assume a simpler reward logic for now: ---
        // Rewarder distributes a fixed amount per claim if the user has a recorded successful proof.
        // We'll hardcode a reward amount and update it if needed.
        uint256 rewardAmount = 100 * (10 ** qainToken.decimals()); // Example: 100 QAIN tokens

        // Check if sufficient tokens are in the Rewarder contract
        require(qainToken.balanceOf(address(this)) >= rewardAmount, "Insufficient tokens in Rewarder");

        // Mark as claimed and distribute reward
        hasClaimedReward[msg.sender] = true;
        qainToken.transfer(msg.sender, rewardAmount);

        emit RewardDistributed(msg.sender, rewardAmount);
    }

    // To allow the owner to withdraw any excess tokens
    function withdrawExcessTokens(uint256 amount) public onlyOwner {
        require(amount > 0, "Amount must be greater than zero");
        require(qainToken.balanceOf(address(this)) >= amount, "Insufficient tokens to withdraw");
        qainToken.transfer(owner(), amount);
    }

    // Function to update the ProofOfAI contract address if needed
    function updateProofOfAIContract(address _newProofOfAIAddress) public onlyOwner {
        proofOfAIContract = ProofOfAI(_newProofOfAIAddress);
    }
}
ProofOfAI.sol (AI Verification)

This contract will store and verify the integrity of AI model outputs. We need to define what constitutes a "proof" and how it's verified.
Design choice: We can store a hash of the AI model's parameters/output, along with a signature from an authorized oracle or a verifiable claim.
For simplicity, let's assume an external entity (like the Chainlink adapter) will submit a proofHash and metadataHash after performing verification.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";

contract ProofOfAI is Ownable {
    struct AIProof {
        address submitter;
        uint256 timestamp;
        bytes32 metadataHash; // Hash of model config, training data info etc.
        bytes32 outputHash;   // Hash of the AI model's actual output
        bool isValid;         // Flag to indicate if the proof has been verified
        // Add a reference to the quantum oracle if needed for enhanced security
        // uint256 quantumRandomnessSeed;
    }

    // Mapping to store proofs by a unique ID
    mapping(uint256 => AIProof) public proofs;
    uint256 public proofCount;

    // Mapping to track if a user has submitted a valid proof (for reward eligibility)
    mapping(address => bool) public userHasValidProof;

    event ProofSubmitted(uint256 indexed proofId, address indexed submitter, bytes32 metadataHash, bytes32 outputHash);
    event ProofVerified(uint256 indexed proofId, address indexed verifier, bytes32 metadataHash, bytes32 outputHash);

    constructor() {
        proofCount = 0;
    }

    // Function to submit a potential AI proof. The verification happens off-chain.
    function submitProof(bytes32 _metadataHash, bytes32 _outputHash) public {
        proofCount++;
        proofs[proofCount] = AIProof({
            submitter: msg.sender,
            timestamp: block.timestamp,
            metadataHash: _metadataHash,
            outputHash: _outputHash,
            isValid: false // Initially not verified
        });

        emit ProofSubmitted(proofCount, msg.sender, _metadataHash, _outputHash);
    }

    // Function to mark a proof as verified (called by an authorized verifier/oracle)
    function verifyProof(uint256 _proofId) public onlyOwner { // Only owner for now, can be modified
        require(_proofId > 0 && _proofId <= proofCount, "Invalid proof ID");
        AIProof storage proof = proofs[_proofId];
        require(!proof.isValid, "Proof already verified");

        proof.isValid = true;
        userHasValidProof[proof.submitter] = true; // Mark submitter as eligible for reward

        emit ProofVerified(_proofId, msg.sender, proof.metadataHash, proof.outputHash);
    }

    // Function to check if a user is eligible for a reward (called by Rewarder contract)
    function checkIfEligibleForReward(address _user) public view returns (bool) {
        return userHasValidProof[_user];
    }

    // Function to get the details of a specific proof
    function getProof(uint256 _proofId) public view returns (address submitter, uint256 timestamp, bytes32 metadataHash, bytes32 outputHash, bool isValid) {
        require(_proofId > 0 && _proofId <= proofCount, "Invalid proof ID");
        AIProof storage proof = proofs[_proofId];
        return (proof.submitter, proof.timestamp, proof.metadataHash, proof.outputHash, proof.isValid);
    }

    // Function to get the total number of valid proofs submitted by a user
    function getValidProofCountForUser(address _user) public view returns (uint256) {
        uint256 count = 0;
        // This is inefficient! We'd need to iterate or maintain a separate counter.
        // For demonstration, let's assume we maintain a count or iterate over submitted proofs.
        // A better approach is to use a mapping from user to count.
        // For example: mapping(address => uint256) public userValidProofCount;
        // And increment it in verifyProof.

        // Let's add that:
        return 0; // Placeholder, will implement later in a refined version.
    }
}
Refinement for ProofOfAI.sol: Let's add the userValidProofCount mapping and update verifyProof to increment it.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";

contract ProofOfAI is Ownable {
    struct AIProof {
        address submitter;
        uint256 timestamp;
        bytes32 metadataHash; // Hash of model config, training data info etc.
        bytes32 outputHash;   // Hash of the AI model's actual output
        bool isValid;         // Flag to indicate if the proof has been verified
    }

    mapping(uint256 => AIProof) public proofs;
    uint256 public proofCount;

    // Mapping to track if a user has submitted a valid proof (for reward eligibility)
    mapping(address => uint256) public userValidProofCount; // Stores the count of valid proofs

    event ProofSubmitted(uint256 indexed proofId, address indexed submitter, bytes32 metadataHash, bytes32 outputHash);
    event ProofVerified(uint256 indexed proofId, address indexed verifier, bytes32 metadataHash, bytes32 outputHash);

    constructor() {
        proofCount = 0;
    }

    function submitProof(bytes32 _metadataHash, bytes32 _outputHash) public {
        proofCount++;
        proofs[proofCount] = AIProof({
            submitter: msg.sender,
            timestamp: block.timestamp,
            metadataHash: _metadataHash,
            outputHash: _outputHash,
            isValid: false
        });

        emit ProofSubmitted(proofCount, msg.sender, _metadataHash, _outputHash);
    }

    function verifyProof(uint256 _proofId) public onlyOwner { // Can be modified to accept specific verifiers
        require(_proofId > 0 && _proofId <= proofCount, "Invalid proof ID");
        AIProof storage proof = proofs[_proofId];
        require(!proof.isValid, "Proof already verified");

        proof.isValid = true;
        userValidProofCount[proof.submitter]++; // Increment the count for the submitter

        emit ProofVerified(_proofId, msg.sender, proof.metadataHash, proof.outputHash);
    }

    // Function to check if a user is eligible for a reward (has at least one valid proof)
    function isEligibleForReward(address _user) public view returns (bool) {
        return userValidProofCount[_user] > 0;
    }

    function getProof(uint256 _proofId) public view returns (address submitter, uint256 timestamp, bytes32 metadataHash, bytes32 outputHash, bool isValid) {
        require(_proofId > 0 && _proofId <= proofCount, "Invalid proof ID");
        AIProof storage proof = proofs[_proofId];
        return (proof.submitter, proof.timestamp, proof.metadataHash, proof.outputHash, proof.isValid);
    }

    function getValidProofCountForUser(address _user) public view returns (uint256) {
        return userValidProofCount[_user];
    }
}
QuantumOracle.sol (Quantum Randomness Oracle)

This contract will store quantum-generated random numbers. It will interact with the Chainlink adapter which will provide the data.
Design: We'll define a structure to hold the random numbers and an owner-only function to update them. The Chainlink adapter will call an intermediary function that Chainlink manages.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"; // Example if using price feeds

contract QuantumOracle is Ownable {
    // For simplicity, we'll store a single latest random number.
    // You might want to store a history or a set of numbers.
    uint256 public latestRandomNumber;
    uint256 public latestRandomnessTimestamp;

    // Events to log updates
    event RandomNumberUpdated(uint256 randomNumber, uint256 timestamp);

    // Constructor
    constructor() {
        latestRandomNumber = 0; // Initialize with a default value
        latestRandomnessTimestamp = 0;
    }

    // Function to set the random number (intended to be called by a Chainlink Oracle)
    // This function is the "target" for Chainlink's fulfillment.
    // The Chainlink adapter will make a transaction to call this.
    function setRandomNumber(uint256 _randomNumber) public onlyOwner { // onlyOwner initially, can be role-based
        latestRandomNumber = _randomNumber;
        latestRandomnessTimestamp = block.timestamp;
        emit RandomNumberUpdated(_randomNumber, block.timestamp);
    }

    // Function to get the latest random number
    function getRandomNumber() public view returns (uint256) {
        return latestRandomNumber;
    }

    function getRandomnessTimestamp() public view returns (uint256) {
        return latestRandomnessTimestamp;
    }

    // To allow the owner to withdraw any excess tokens if this contract
    // were to hold any (not applicable for this design but good practice for ownable contracts)
    // function withdrawExcessTokens(uint256 amount) public onlyOwner { ... }

    // Function to update the owner (if needed)
    // function transferOwnership(address newOwner) public virtual onlyOwner { ... }
}
3. Deployment Scripts (scripts/)

We need a script to deploy these contracts to a network.

// scripts/deploy.js
const hre = require("hardhat");

async function main() {
  // 1. Deploy QAINToken
  const initialSupply = 1000000; // Example: 1 million tokens
  const QAINToken = await hre.ethers.getContractFactory("QAINToken");
  const qainToken = await QAINToken.deploy(initialSupply * (10**18)); // Assume 18 decimals for token
  await qainToken.deployed();
  console.log(`QAINToken deployed to: ${qainToken.address}`);

  // 2. Deploy ProofOfAI
  const ProofOfAI = await hre.ethers.getContractFactory("ProofOfAI");
  const proofOfAI = await ProofOfAI.deploy();
  await proofOfAI.deployed();
  console.log(`ProofOfAI deployed to: ${proofOfAI.address}`);

  // 3. Deploy Rewarder
  // Pass addresses of deployed QAINToken and ProofOfAI contracts
  const Rewarder = await hre.ethers.getContractFactory("Rewarder");
  const rewarder = await Rewarder.deploy(qainToken.address, proofOfAI.address);
  await rewarder.deployed();
  console.log(`Rewarder deployed to: ${rewarder.address}`);

  // 4. Deploy QuantumOracle
  const QuantumOracle = await hre.ethers.getContractFactory("QuantumOracle");
  const quantumOracle = await QuantumOracle.deploy();
  await quantumOracle.deployed();
  console.log(`QuantumOracle deployed to: ${quantumOracle.address}`);

  // --- Post-deployment configuration ---

  // Grant ownership of ProofOfAI to the Rewarder if needed, or keep it separate.
  // For now, let's assume the owner of ProofOfAI is the deployer, and will verify proofs.

  // If you want the Rewarder to be able to update the ProofOfAI contract,
  // you'd need to call updateProofOfAIContract on Rewarder.
  // However, the primary interaction is ProofOfAI notifying Rewarder eligibility,
  // not Rewarder controlling ProofOfAI.

  // If the owner of ProofOfAI needs to be the deployer to verify,
  // and the deployer is also the owner of Rewarder, then they can verify.
  // Let's assume for now the deployer (owner) is responsible for verification.

  // If you want to deposit initial QAIN tokens into the Rewarder:
  // const initialRewardAmount = hre.ethers.utils.parseUnits("10000", 18); // 10,000 QAIN
  // await qainToken.approve(rewarder.address, initialRewardAmount); // Approve Rewarder to spend tokens
  // await rewarder.depositTokens(initialRewardAmount); // Deposit tokens
  // console.log(`Deposited ${initialRewardAmount} QAIN tokens into Rewarder.`);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
4. Running Deployments

Compile Contracts:

npx hardhat compile
Run Deployment Script:

First, you'll need to set up a .env file in your project root with your private key and Alchemy API key.

# .env file
ALCHEMY_API_KEY=YOUR_ALCHEMY_API_KEY
PRIVATE_KEY=YOUR_WALLET_PRIVATE_KEY
ETHERSCAN_API_KEY=YOUR_ETHERSCAN_API_KEY
Make sure your hardhat.config.js is set up to use these variables and includes the Sepolia network.

# Deploy to Sepolia testnet (example)
npx hardhat run scripts/deploy.js --network sepolia
This concludes Phase 1. We have a robust set of smart contracts and the initial setup for deploying them.
