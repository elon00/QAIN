Phase 5: Integration and End-to-End Testing
Goal: To connect the Smart Contracts, Python Quantum Service, Chainlink Adapter, and React Frontend into a cohesive, functional application and test the entire workflow.

Deliverables:

A thoroughly tested workflow covering the core QAIN functionalities.
Identification and resolution of integration issues.
Confirmation that data flows correctly between all layers.
Workflow to Test:

Let's define the key user journeys and the technical flow for each:

User Submits an AI Proof:

Frontend: User enters hashes, clicks "Submit Proof".
Frontend -> Smart Contract: Frontend sends submitProof(metadataHash, outputHash) transaction to ProofOfAI.sol.
Smart Contract: ProofOfAI.sol records the proof with isValid = false.
Frontend: Displays success message with transaction hash.
AI Proof Verification (Manual/Chainlink triggered):

Scenario A (Manual Verification):
Admin/Owner: Uses npx hardhat run scripts/verify_proof.js --network sepolia <proofId> (we'll need to create this script) to call verifyProof(proofId) on ProofOfAI.sol.
Smart Contract: ProofOfAI.sol sets isValid = true and increments userValidProofCount.
Scenario B (Chainlink Verification - More Advanced):
Chainlink Job: A Chainlink job is configured to:
Potentially trigger an external verification service or use a VRF for randomness to validate the submitted proof hash (complex).
If verified, call verifyProof(proofId) on ProofOfAI.sol.
User Claims Reward:

Frontend: User views their eligibility (based on ProofOfAI.isEligibleForReward).
Frontend -> Smart Contract: User clicks "Claim Reward", frontend sends claimReward() transaction to Rewarder.sol.
Smart Contract: Rewarder.sol checks eligibility via ProofOfAI.isEligibleForReward, checks hasClaimedReward, and transfers QAIN tokens if conditions are met.
Frontend: Displays success and updates balance.
Quantum Randomness Update:

Chainlink Automation/Job: Trigger mechanism (e.g., cron schedule) initiates the Chainlink adapter.
Chainlink Adapter:
Calls Python service /generate_random_number.
Receives random number.
Sends setRandomNumber(randomNumber) transaction to QuantumOracle.sol.
Smart Contract: QuantumOracle.sol updates latestRandomNumber.
Frontend: A separate component can fetch and display QuantumOracle.latestRandomNumber.
Step 5.1: Create Helper Scripts for Testing

We need ways to manually trigger or inspect things for testing.

1. scripts/verify_proof.js

This script will allow you to manually verify a proof submission.

// scripts/verify_proof.js
const hre = require("hardhat");

async function main() {
    const proofId = process.argv[2]; // Get proofId from command line arguments
    const PROOF_OF_AI_ADDRESS = process.env.PROOF_OF_AI_ADDRESS; // Ensure this is in .env for the script

    if (!proofId) {
        console.error("Please provide the proof ID as a command-line argument.");
        process.exit(1);
    }
    if (!PROOF_OF_AI_ADDRESS) {
        console.error("PROOF_OF_AI_ADDRESS not found in .env");
        process.exit(1);
    }

    const ProofOfAI = await hre.ethers.getContractFactory("ProofOfAI");
    const proofOfAI = ProofOfAI.attach(PROOF_OF_AI_ADDRESS);

    console.log(`Verifying proof with ID: ${proofId}`);

    try {
        // Check if the proof exists and is not already verified
        const proof = await proofOfAI.proofs(proofId);
        if (proof.isValid) {
            console.log(`Proof ID ${proofId} is already verified.`);
            return;
        }

        const tx = await proofOfAI.verifyProof(proofId);
        console.log(`Verification transaction sent: ${tx.hash}`);
        const receipt = await tx.wait();

        console.log(`Transaction mined in block: ${receipt.blockNumber}`);
        if (receipt.status === 1) {
            console.log(`Proof ID ${proofId} successfully verified!`);
        } else {
            console.error(`Verification transaction failed.`);
        }
    } catch (error) {
        console.error(`Error verifying proof ${proofId}:`, error);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
Setup .env for scripts: Make sure your .env file (or a dedicated .env.scripts file) has PROOF_OF_AI_ADDRESS and network configuration (RPC_URL, PRIVATE_KEY).
2. scripts/deposit_tokens.js

A script to deposit initial QAIN tokens into the Rewarder contract.

// scripts/deposit_tokens.js
const hre = require("hardhat");

async function main() {
    const amountToDeposit = hre.ethers.utils.parseUnits("10000", 18); // 10,000 QAIN tokens (assuming 18 decimals)

    const QAIN_TOKEN_ADDRESS = process.env.QAIN_TOKEN_ADDRESS; // From .env
    const REWARDER_ADDRESS = process.env.REWARDER_ADDRESS; // From .env

    if (!QAIN_TOKEN_ADDRESS || !REWARDER_ADDRESS) {
        console.error("QAIN_TOKEN_ADDRESS or REWARDER_ADDRESS not found in .env");
        process.exit(1);
    }

    const QAINToken = await hre.ethers.getContractFactory("QAINToken");
    const qainToken = QAINToken.attach(QAIN_TOKEN_ADDRESS);

    const Rewarder = await hre.ethers.getContractFactory("Rewarder");
    const rewarder = Rewarder.attach(REWARDER_ADDRESS);

    console.log(`Depositing ${hre.ethers.utils.formatUnits(amountToDeposit, 18)} QAIN to Rewarder at ${REWARDER_ADDRESS}...`);

    try {
        // Approve the Rewarder contract to spend QAIN tokens
        console.log(`Approving Rewarder to spend ${hre.ethers.utils.formatUnits(amountToDeposit, 18)} QAIN...`);
        const approveTx = await qainToken.approve(REWARDER_ADDRESS, amountToDeposit);
        await approveTx.wait();
        console.log(`Approval transaction mined: ${approveTx.hash}`);

        // Deposit the tokens
        console.log("Depositing tokens...");
        const depositTx = await rewarder.depositTokens(amountToDeposit);
        await depositTx.wait();
        console.log(`Deposit transaction mined: ${depositTx.hash}`);

        console.log("Tokens deposited successfully!");
    } catch (error) {
        console.error("Error during token deposit:", error);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
Setup .env for scripts: Ensure QAIN_TOKEN_ADDRESS and REWARDER_ADDRESS are set.
Step 5.2: Setup Python Service URL in Frontend

If your frontend needs to directly call your Python service (e.g., to get the latest random number or trigger an AI optimization directly without Chainlink), you need to ensure the Python service is accessible from your browser.

Local Testing: If running both frontend and Python service on your local machine, the Python service URL (http://127.0.0.1:5000) might work directly.
Deployment: If you deploy your Python service, you'll need to make it accessible (e.g., via 0.0.0.0 in app.py and potentially opening firewall ports). You'll then update VITE_PYTHON_SERVICE_URL in frontend/.env.
For this integration phase, we'll assume the Chainlink adapter is the primary mechanism for submitting data to the blockchain from the Python service. The frontend will read data from the blockchain, not necessarily call the Python service directly for critical operations.

Step 5.3: Testing the End-to-End Flow

Environment Setup:

Deploy Contracts: Ensure your contracts are deployed to Sepolia (or your chosen testnet).
Start Python Service: Run cd quantum-service && source venv/bin/activate && python app.py.
Start Frontend: Run cd frontend && npm run dev.
Configure Chainlink Adapter:
For local testing: Run cd chainlink-adapter && node run-adapter.js. This will execute the adapter once.
For automated testing: Set up and run a Chainlink Keeper node with the job spec to automate the run-adapter.js logic.
Test Case 1: Submitting and Verifying an AI Proof, then Claiming Reward

Connect Wallet: Open the frontend, connect your wallet (MetaMask).
Submit Proof:
Generate placeholder hashes (e.g., 0x followed by 64 hex characters). You can use ethers.utils.formatBytes32String("my_metadata_hash") or ethers.utils.keccak256(ethers.utils.toUtf8Bytes("my_metadata_hash")) in your browser console to create valid inputs for testing.
Enter these into the "Submit Proof" component and click the button.
Approve the transaction in MetaMask.
You should see the success message.
Verify Proof (Manually):
Go to your project's root directory.
Run npx hardhat run scripts/verify_proof.js --network sepolia <proofId>.
How to get <proofId>: You'll need to inspect the ProofSubmitted event emitted by the ProofOfAI contract. You can do this by:
Using a block explorer (like Etherscan for Sepolia) and looking up transactions submitted by your frontend. Find the ProofSubmitted event in the transaction details.
Adding event listeners in your frontend to log submitted proof IDs.
If you have contract interaction history or logs from your Hardhat deploy script, you might find it there.
For a quick test, you can add a frontend component to list submitted proofs and their IDs.
Approve the verification transaction in MetaMask.
You should see confirmation that the proof was verified.
Claim Reward:
Go back to the frontend. The "Claim Reward" section should now show you are eligible.
Click "Claim Reward".
Approve the transaction in MetaMask.
You should see the success message, and your QAIN balance should update.
Test Case 2: Quantum Randomness Update

Check Initial State: On the frontend, if you add a component to display QuantumOracle.latestRandomNumber, it should show the last known value (or 0 initially).
Trigger Chainlink Adapter:
Local Test: Run cd chainlink-adapter && node run-adapter.js.
Automated Test: Wait for your Chainlink Keeper job to run.
Observe Results:
The adapter should call the Python service, receive a random number, and submit it to the QuantumOracle.sol contract.
Check the transaction on Etherscan to confirm it was successful.
Refresh the frontend (or add real-time updates using WebSockets/polling) to see the latestRandomNumber updated.
Key Integration Points to Verify:

ABI Compatibility: Ensure the ABIs used in the frontend and Chainlink adapter match the deployed contract versions exactly.
Address Consistency: Double-check that all addresses in .env files are correct for the network you're targeting.
Data Formatting:
Hashes submitted from frontend to contract: Are they correctly interpreted as bytes32?
Random numbers from Python service to adapter and contract: Are they passed as uint256 correctly?
Wallet Permissions: Does MetaMask correctly prompt for and approve transactions from the frontend?
Chainlink Job Configuration: Is the Chainlink job spec correctly defined, including URLs, contract interactions, and gas parameters?
Python Service Accessibility: Can the Chainlink adapter (or external verification service) reach the Python service's API endpoints?
Troubleshooting Tips:

Console Logs: Use console.log liberally in your frontend, adapter, and Python service to trace execution.
Block Explorer: Use Etherscan (or your network's equivalent) to inspect transaction details, event logs, and contract states.
MetaMask Debugging: MetaMask's activity tab and error messages can be helpful.
Network Selection: Ensure your wallet and RPC URLs are pointed to the correct network (e.g., Sepolia).
This phase is iterative. You might find issues that require going back to previous phases to adjust code.
