Phase 3: JavaScript Chainlink Adapter
Goal: Develop the crucial middleware that bridges your Python Quantum Service with the Ethereum blockchain using Chainlink. This adapter will fetch data from your Python service and submit it to your smart contracts via Chainlink Oracles.

Deliverables:

A Node.js project structure for the Chainlink adapter.
JavaScript code that:
Fetches quantum random numbers from your Python service.
Submits these numbers to the QuantumOracle.sol contract.
(Later) Submits AI proof verification status to ProofOfAI.sol.
Configuration for Chainlink jobs (using Chainlink Automation or Keepers/External Adapters).
Key Concepts for this Phase:

Chainlink Automation (formerly Keepers): For reliable, decentralized on-demand execution of smart contracts. We can use it to trigger our adapter.
Chainlink Oracle: Your Python service will act as the "off-chain" component. The adapter will be the "on-chain" component's interface.
@chainlink/functions-sdk or direct contract calls: We'll use a method to trigger Chainlink to call our service and then submit the result. A common pattern is using an external adapter triggered by Automation.
Step 1: Project Setup for Chainlink Adapter

We'll create a separate directory for the Chainlink adapter.

# From the root of your qain-project directory
mkdir chainlink-adapter
cd chainlink-adapter
Initialize a Node.js project:

npm init -y
Install necessary dependencies:

npm install --save ethers @chainlink/contracts @chainlink/automation-toolkit dotenv axios
ethers: For interacting with the Ethereum blockchain.
@chainlink/contracts: Provides ABIs and contract interfaces for Chainlink.
@chainlink/automation-toolkit: Helpful for automating Chainlink jobs (especially if you run a keeper node yourself or want to test).
dotenv: To manage environment variables.
axios: To make HTTP requests to your Python service.
Step 2: Environment Variables (.env)

Create a .env file in the chainlink-adapter directory. You'll need:

Your wallet's private key (for signing transactions).
The RPC URL for the network you're deploying to (e.g., Sepolia).
The addresses of your deployed smart contracts (QuantumOracle.sol, ProofOfAI.sol, QAINToken.sol, Rewarder.sol).
The URL of your running Python Quantum Service.
# chainlink-adapter/.env

# Network Configuration (e.g., Sepolia)
SEPOLIA_RPC_URL=YOUR_SEPOLIA_RPC_URL # e.g., from Alchemy, Infura
PRIVATE_KEY=YOUR_WALLET_PRIVATE_KEY

# Smart Contract Addresses (Deployed from Phase 1)
QUANTUM_ORACLE_ADDRESS=YOUR_QUANTUM_ORACLE_ADDRESS
PROOF_OF_AI_ADDRESS=YOUR_PROOF_OF_AI_ADDRESS
# Other contract addresses if needed for adapter logic

# Your Python Quantum Service URL
PYTHON_SERVICE_URL=http://your-python-service-ip:5000
Step 3: Chainlink Adapter Logic (adapter.js or index.js)

We'll create a script that performs the following:

Fetches Data: Makes an HTTP GET request to your Python service's /generate_random_number endpoint.
Prepares Data: Parses the JSON response.
Submits to Contract: Calls the setRandomNumber function on your QuantumOracle.sol contract.
Let's create src/adapter.js (you can organize this better if you prefer).

// chainlink-adapter/src/adapter.js

require('dotenv').config();
const { ethers } = require("ethers");
const axios = require("axios");

// --- Configuration ---
const PYTHON_SERVICE_URL = process.env.PYTHON_SERVICE_URL;
const QUANTUM_ORACLE_ADDRESS = process.env.QUANTUM_ORACLE_ADDRESS;
const SEPOLIA_RPC_URL = process.env.SEPOLIA_RPC_URL;
const PRIVATE_KEY = process.env.PRIVATE_KEY;

// --- ABIs ---
// You'll need the ABI for your QuantumOracle contract.
// You can get this from your Hardhat build artifacts or by ABI encoding the function signature.
// For this example, let's assume you have it. If not, you'll compile it.
// abi[] for QuantumOracle.sol can be generated or copied from hardhat/artifacts/...
// For simplicity, let's use a minimal ABI for the function we call:
const quantumOracleAbi = [
    "function setRandomNumber(uint256 _randomNumber)",
    // Event signature for verification later (if needed)
    "event RandomNumberUpdated(uint256 randomNumber, uint256 timestamp)"
];

async function fulfillQuantumRandomnessRequest() {
    if (!PYTHON_SERVICE_URL || !QUANTUM_ORACLE_ADDRESS || !SEPOLIA_RPC_URL || !PRIVATE_KEY) {
        console.error("Error: Missing environment variables. Please check your .env file.");
        return;
    }

    console.log("Starting Quantum Randomness Fulfillment...");

    try {
        // 1. Fetch random number from Python service
        console.log(`Fetching random number from: ${PYTHON_SERVICE_URL}/generate_random_number`);
        const response = await axios.get(`${PYTHON_SERVICE_URL}/generate_random_number?num_bits=32`); // Request 32 bits for a larger number
        const { success, randomNumber, numBits } = response.data;

        if (!success || randomNumber === undefined) {
            throw new Error(`Python service returned an error or no random number: ${response.data.message || 'Unknown error'}`);
        }

        console.log(`Received random number: ${randomNumber} (${numBits}-bit)`);

        // 2. Connect to Ethereum and your contract
        const provider = new ethers.providers.JsonRpcProvider(SEPOLIA_RPC_URL);
        const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
        const quantumOracleContract = new ethers.Contract(QUANTUM_ORACLE_ADDRESS, quantumOracleAbi, wallet);

        // 3. Submit the random number to the QuantumOracle contract
        console.log(`Submitting random number ${randomNumber} to QuantumOracle at ${QUANTUM_ORACLE_ADDRESS}`);

        // Estimate gas (optional but good practice)
        // const gasEstimate = await quantumOracleContract.estimateGas.setRandomNumber(randomNumber);
        // console.log(`Estimated gas for setRandomNumber: ${gasEstimate.toString()}`);

        const tx = await quantumOracleContract.setRandomNumber(randomNumber);
        console.log(`Transaction sent: ${tx.hash}`);

        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        console.log(`Transaction mined in block: ${receipt.blockNumber}`);
        console.log(`Status: ${receipt.status === 1 ? 'Success' : 'Failed'}`);

        if (receipt.status === 1) {
            console.log("Quantum randomness successfully updated on-chain!");
        } else {
            console.error("Transaction failed to update quantum randomness.");
        }

    } catch (error) {
        console.error("Error in fulfillQuantumRandomnessRequest:", error.message);
        // You might want to implement retry logic or alert mechanisms here
    }
}

// --- Export for use with Chainlink Automation ---
// If running directly for testing:
// fulfillQuantumRandomnessRequest();

module.exports = {
    fulfillQuantumRandomnessRequest
};
Step 4: Set up Chainlink Automation (Conceptual & Practical)

There are a few ways to trigger this adapter:

Option A: Using Chainlink Automation (Recommended for Decentralization)

This involves running a Chainlink Keeper node and configuring it to call your adapter.

Deploy your smart contracts to a testnet (e.g., Sepolia). (You've done this in Phase 1).

Set up a Chainlink Keeper Node:

Follow the official Chainlink documentation to install and run a Keeper node: https://docs.chain.link/chainlink-automation/deploy-automation-proxy
You'll need to configure your Keeper to connect to your Sepolia RPC URL and have LINK tokens to pay for job execution.
Create a Job Specification (JSON): This tells the Keeper node what to do. It will typically involve:

A trigger (e.g., a cron-like schedule).
A task to make an HTTP request to your Python service.
A task to encode the received data and send it as a transaction to your QuantumOracle.sol contract.
Example keeper-job.json (Simplified):

{
  "version": 1,
  "type": "offchainreporting",
  "contractID": "YOUR_ORACLE_ADDRESS", // The address of your Chainlink Oracle (if using specific oracle types)
  "chainID": "YOUR_CHAIN_ID", // e.g., 11155111 for Sepolia
  "contractVersion": "YOUR_CONTRACT_VERSION", // If applicable
  "schemaVersion": 1,
  "name": "QAIN Quantum Randomness Oracle",
  "tasks": [
    {
      "type": "httpGet",
      "name": "fetchRandomNumber",
      "url": "YOUR_PYTHON_SERVICE_URL/generate_random_number?num_bits=32",
      "headers": {
        "Accept": "application/json"
      },
      "vars": {
        "randomNumber": "data.randomNumber"
      }
    },
    {
      "type": "ethTx",
      "name": "submitToQuantumOracle",
      "contractID": "QUANTUM_ORACLE_ADDRESS",
      "functionSelector": "setRandomNumber(uint256)",
      "inputs": [
        { "type": "uint256", "value": "$(fetchRandomNumber.randomNumber)" }
      ],
      "from": "YOUR_CHAINLINK_KEEPER_NODE_ADDRESS", // The address of your Keeper node wallet
      "gasLimit": 200000,
      "gasPrice": "auto",
      "txOptions": {
        "chainID": "YOUR_CHAIN_ID"
      }
    }
  ],
  "capabilities": {
    "httpGet": [
      {
        "name": "fetchRandomNumber",
        "url": "YOUR_PYTHON_SERVICE_URL/generate_random_number?num_bits=32"
      }
    ],
    "ethTx": [
      {
        "contractID": "QUANTUM_ORACLE_ADDRESS",
        "functionSelector": "setRandomNumber(uint256)"
      }
    ]
  }
}
Important: You'll need to configure your Keeper node to load this job spec. The vars section is crucial for extracting data. The type: "httpGet" and type: "ethTx" are core Chainlink adapter types. You'll need to replace placeholders like YOUR_PYTHON_SERVICE_URL, QUANTUM_ORACLE_ADDRESS, YOUR_CHAIN_ID, and YOUR_CHAINLINK_KEEPER_NODE_ADDRESS.
Create a Job in your Keeper Node: Once your Keeper node is running, you'll typically submit this job spec via its API or a web UI.

Option B: Using automation-toolkit for Testing (Simpler for Development)

If you just want to test the interaction without setting up a full Keeper node, you can use the @chainlink/automation-toolkit locally.

Save your adapter code: Save the code above as src/adapter.js.

Create a run-adapter.js file:

// chainlink-adapter/run-adapter.js
require('dotenv').config();
const { fulfillQuantumRandomnessRequest } = require('./src/adapter');

async function main() {
    console.log("Running Chainlink Adapter Locally...");
    await fulfillQuantumRandomnessRequest();
    console.log("Local execution finished.");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error("Error running adapter locally:", error);
        process.exit(1);
    });
Run the script:

node run-adapter.js
This will execute the fulfillQuantumRandomnessRequest function once. For actual on-chain automation, you need Option A.

Step 4: Integrate with ProofOfAI (Future)

When you want to also submit AI proof verification status:

Modify Python Service: Add an endpoint to your app.py that fetches AI verification status from your ProofOfAI.sol contract (or receives it from an external verification service) and returns it.
Modify Adapter:
Add logic to call this new Python endpoint.
Add the ABI for ProofOfAI.sol and its relevant function (e.g., verifyProof(uint256 proofId)).
Update your Chainlink Job Spec (if using Option A) to include a task to call verifyProof on ProofOfAI.sol, potentially after the setRandomNumber transaction is confirmed.
Important Considerations for Production:

Security of Private Key: NEVER commit your PRIVATE_KEY to version control. Use environment variables or a secrets management system.
Python Service Availability: Ensure your Python service is running reliably. Consider hosting it on a robust server (e.g., AWS EC2, Google Cloud Run, or a dedicated server).
Chainlink Node Security: If you run your own Keeper node, secure its environment and private keys carefully.
Gas Fees: Monitor gas prices for transactions. Chainlink Automation can help manage this.
Error Handling & Monitoring: Implement robust logging, error handling, and monitoring for both your Python service and the Chainlink adapter.
This is a significant step, as it connects your off-chain logic to the blockchain.
